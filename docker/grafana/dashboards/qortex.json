{
  "annotations": { "list": [] },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 1,
  "id": null,
  "links": [],
  "panels": [
    {
      "title": "Retrieval Health",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 0 },
      "collapsed": false
    },
    {
      "title": "Query Rate (queries/sec)",
      "description": "How many retrieval queries qortex is handling per second, broken down by mode (vec = vector-only, graph = GraphRAG with PPR). A healthy system shows steady throughput. Spikes indicate burst traffic; drops may indicate upstream issues or backpressure.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 1 },
      "targets": [
        {
          "expr": "rate(qortex_queries_total[5m])",
          "legendFormat": "{{mode}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "reqps"
        }
      }
    },
    {
      "title": "Query Latency (p50/p95/p99)",
      "description": "End-to-end query latency percentiles. Includes embedding generation, vector search, PPR (if graph mode), and result assembly. p50 is the typical user experience; p95/p99 capture tail latency. If p99 spikes while p50 stays flat, a subset of queries is hitting slow paths (large PPR graphs, cold embeddings).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 1 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_query_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_query_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        },
        {
          "expr": "histogram_quantile(0.99, rate(qortex_query_duration_seconds_bucket[5m]))",
          "legendFormat": "p99"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vec Search Latency (p50/p95)",
      "description": "Latency of the vector similarity search step alone (cosine similarity over the embedding index). This is typically the fastest part of the pipeline. If this spikes, the vector index may need rebuilding or the index has grown too large for in-memory search.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 9 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_vec_search_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_vec_search_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Query Errors",
      "description": "Rate of query failures by pipeline stage: 'embedding' (text-to-vector failed), 'vec_search' (index lookup failed), 'ppr' (PageRank computation failed). Each error emits a QueryFailed event. Non-zero values here mean queries are being dropped — investigate the specific stage.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 9 },
      "targets": [
        {
          "expr": "rate(qortex_query_errors_total[5m])",
          "legendFormat": "{{stage}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Learning Dynamics",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 17 },
      "collapsed": false
    },
    {
      "title": "Factor Mean Over Time",
      "description": "Average teleportation factor across all nodes in the knowledge graph. Teleportation factors control how strongly PPR biases toward specific nodes during random walks. A rising mean indicates the system is learning stronger preferences from feedback; a falling mean suggests uncertainty or conflicting signals.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 18 },
      "targets": [
        {
          "expr": "qortex_factor_mean",
          "legendFormat": "mean factor"
        }
      ]
    },
    {
      "title": "Factor Entropy",
      "description": "Shannon entropy of the teleportation factor distribution. High entropy = factors are spread evenly (the system hasn't formed strong opinions yet). Low entropy = factors are concentrated on a few nodes (the system has learned clear preferences). Entropy should decrease over time as the system accumulates feedback.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 18 },
      "targets": [
        {
          "expr": "qortex_factor_entropy",
          "legendFormat": "entropy"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "bits"
        }
      }
    },
    {
      "title": "Factor Update Rate",
      "description": "How frequently teleportation factors are being updated, by feedback outcome (accepted/rejected/partial). Each update adjusts how PPR weights specific nodes. High update rates indicate active learning; the balance of accepted vs rejected shows whether the system's suggestions are landing.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 18 },
      "targets": [
        {
          "expr": "rate(qortex_factor_updates_total[5m])",
          "legendFormat": "{{outcome}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Feedback Accept/Reject Ratio",
      "description": "Rate of user/system feedback events classified as accepted vs rejected. This is the raw signal that drives all learning in qortex — both teleportation factor updates and bandit posterior updates. A healthy system trends toward more accepts over time as learning kicks in. A sustained high rejection rate may indicate poor initial candidates or a domain mismatch.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 26 },
      "targets": [
        {
          "expr": "rate(qortex_feedback_total{outcome=\"accepted\"}[5m])",
          "legendFormat": "accepted"
        },
        {
          "expr": "rate(qortex_feedback_total{outcome=\"rejected\"}[5m])",
          "legendFormat": "rejected"
        }
      ]
    },
    {
      "title": "KG Crystallization",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 34 },
      "collapsed": false
    },
    {
      "title": "KG Coverage Ratio",
      "description": "Fraction of the knowledge graph that has been 'covered' by online edges (runtime-discovered relationships). 0% = no runtime edges, purely static graph. 100% = every node has at least one online edge. Coverage above 70% (green) indicates the system has explored most of the graph through real usage.",
      "type": "gauge",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 35 },
      "targets": [
        {
          "expr": "qortex_kg_coverage",
          "legendFormat": "coverage"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit",
          "thresholds": {
            "steps": [
              { "color": "red", "value": null },
              { "color": "yellow", "value": 0.3 },
              { "color": "green", "value": 0.7 }
            ]
          }
        }
      }
    },
    {
      "title": "Buffer Size & Promotions",
      "description": "Online edges live in a buffer before being promoted to the persistent knowledge graph. 'Buffered' shows how many edges are waiting; 'promotions/hr' shows how fast they're graduating. A growing buffer with no promotions means edges aren't meeting the confidence threshold for persistence.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 35 },
      "targets": [
        {
          "expr": "qortex_buffer_edges",
          "legendFormat": "buffered"
        },
        {
          "expr": "rate(qortex_edges_promoted_total[1h])",
          "legendFormat": "promotions/hr"
        }
      ]
    },
    {
      "title": "Total Promoted (lifetime)",
      "description": "Cumulative count of online edges that have been promoted from the buffer into the persistent knowledge graph. This is the system's 'crystallized learning' — relationships it discovered at runtime and deemed confident enough to keep permanently.",
      "type": "stat",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 35 },
      "targets": [
        {
          "expr": "qortex_edges_promoted_total",
          "legendFormat": "total promoted"
        }
      ]
    },
    {
      "title": "PPR Performance",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 43 },
      "collapsed": false
    },
    {
      "title": "PPR Executions / sec",
      "description": "Rate of Personalized PageRank computations. Each graph-mode query triggers one PPR run, which performs power iteration over the knowledge graph to rank nodes by relevance. More PPR runs = more graph-mode queries being served.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 44 },
      "targets": [
        {
          "expr": "rate(qortex_ppr_started_total[5m])",
          "legendFormat": "PPR runs/sec"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "PPR Iterations to Convergence",
      "description": "Distribution of how many power-iteration steps PPR needs before the score vector stabilizes (within tolerance). Fewer iterations = faster convergence = simpler graph structure. If many runs cluster at the maximum (100), the graph may have pathological structure or the tolerance is too tight.",
      "type": "histogram",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 44 },
      "targets": [
        {
          "expr": "rate(qortex_ppr_iterations_bucket[5m])",
          "legendFormat": "{{le}}"
        }
      ]
    },
    {
      "title": "Active Factors & Node Count",
      "description": "Number of nodes in the knowledge graph that have non-default teleportation factors. These are nodes the system has formed an opinion about based on feedback. Growing = the system is learning about more of the graph. Flat = no new feedback is reaching new nodes.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 44 },
      "targets": [
        {
          "expr": "qortex_factors_active",
          "legendFormat": "active factors"
        }
      ]
    },
    {
      "title": "Online Edge Generation",
      "description": "How many online edges are being generated per query (edges/query) and the overall event rate (events/sec). Online edges are runtime-discovered relationships between concepts, inferred from co-occurrence in query results. More edges per query = richer associative structure being captured.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 52 },
      "targets": [
        {
          "expr": "qortex_online_edge_count",
          "legendFormat": "edges / query"
        },
        {
          "expr": "rate(qortex_online_edges_generated_total[5m])",
          "legendFormat": "generation events / sec"
        }
      ]
    },
    {
      "title": "KG Coverage Over Time",
      "description": "Time series of knowledge graph coverage. Shows how the graph's explored territory grows as the system processes queries. Monotonically increasing in a healthy system. Plateaus indicate the system has explored most reachable nodes; jumps indicate new domains or concept batches being ingested.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 52 },
      "targets": [
        {
          "expr": "qortex_kg_coverage",
          "legendFormat": "coverage"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit"
        }
      }
    },
    {
      "title": "Enrichment & Ingestion",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 60 },
      "collapsed": false
    },
    {
      "title": "Enrichment Rate",
      "description": "Rate of LLM enrichment calls by backend type. Enrichment uses an LLM to extract structured relationships from raw text when ingesting new concepts. Higher rates mean more content is being processed. The backend_type label distinguishes different LLM providers (openai, anthropic, local).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 61 },
      "targets": [
        {
          "expr": "rate(qortex_enrichment_total[5m])",
          "legendFormat": "{{backend_type}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Enrichment Latency (p50/p95)",
      "description": "How long LLM enrichment calls take. This is dominated by the LLM's response time. p50 is the typical call; p95 captures retries and long-context extractions. If p95 is significantly higher than p50, some documents are much harder to enrich than others.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 61 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_enrichment_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_enrichment_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Enrichment Fallbacks",
      "description": "Rate of enrichment fallbacks — when the primary LLM backend fails and the system falls back to a simpler extraction method. Non-zero rates here mean the LLM is unreliable; consistently high rates may warrant switching providers or increasing timeouts.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 61 },
      "targets": [
        {
          "expr": "rate(qortex_enrichment_fallbacks_total[5m])",
          "legendFormat": "fallbacks/sec"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Ingestion Rate",
      "description": "Rate of manifest ingestion events by domain. A manifest is a batch of concepts being added to the knowledge graph. Each domain (e.g. 'prompts', 'code', 'docs') tracks independently. Spikes indicate bulk imports; steady rates indicate continuous ingestion pipelines.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 69 },
      "targets": [
        {
          "expr": "rate(qortex_manifests_ingested_total[5m])",
          "legendFormat": "{{domain}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Ingest Latency (p50/p95)",
      "description": "Time taken to ingest a manifest (create nodes, generate embeddings, add to vector index, insert edges). Includes all backend writes. Latency depends on manifest size and backend type (InMemory is fast, Memgraph adds network round-trips).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 69 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_ingest_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_ingest_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vector Index",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 77 },
      "collapsed": false
    },
    {
      "title": "Vec Index Size",
      "description": "Total number of embedding vectors stored in the index. Each concept in the knowledge graph has one vector. This is the system's 'memory size' — how many concepts it can search over. Growth indicates new concepts being ingested.",
      "type": "stat",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 6, "x": 0, "y": 78 },
      "targets": [
        {
          "expr": "qortex_vec_index_size",
          "legendFormat": "vectors"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Add Rate",
      "description": "Rate of vectors being added to the index, by index type (numpy = in-memory, or external). Each add operation embeds a concept and inserts it into the searchable index. Correlates with ingestion rate but can differ if concepts are updated (re-embedded).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 9, "x": 6, "y": 78 },
      "targets": [
        {
          "expr": "rate(qortex_vec_add_total[5m])",
          "legendFormat": "{{index_type}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "ops"
        }
      }
    },
    {
      "title": "Vec Add Latency (p50/p95)",
      "description": "Time to insert a vector into the index. For NumpyVectorIndex this is a fast array append. For external indices (future: FAISS, pgvector), this includes network overhead. Sub-millisecond is healthy for in-memory.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 9, "x": 15, "y": 78 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_vec_add_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_vec_add_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vec Search Top Score",
      "description": "Cosine similarity of the best-matching vector in the most recent search. Range 0-1, where 1.0 = exact match. Scores above 0.8 indicate strong semantic matches. Consistently low scores (< 0.5) suggest the query domain isn't well-represented in the index — more relevant concepts may need to be ingested.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 86 },
      "targets": [
        {
          "expr": "qortex_vec_search_top_score",
          "legendFormat": "top score"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Search Score Spread",
      "description": "Difference between the highest and lowest cosine similarity scores in the most recent search results. A large spread means the top result is much more relevant than the bottom result (good discrimination). A narrow spread means all candidates scored similarly (the query is either too generic or too specific).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 86 },
      "targets": [
        {
          "expr": "qortex_vec_search_score_spread",
          "legendFormat": "spread"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Seed Yield",
      "description": "Ratio of vector search results that survive domain filtering. Yield of 1.0 = all results were in the requested domain. Yield of 0.3 = 70% of results were filtered out because they belonged to other domains. Low yield means the index is dominated by other domains; consider domain-specific indices.",
      "type": "gauge",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 86 },
      "targets": [
        {
          "expr": "qortex_vec_seed_yield",
          "legendFormat": "yield"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit",
          "thresholds": {
            "steps": [
              { "color": "red", "value": null },
              { "color": "yellow", "value": 0.5 },
              { "color": "green", "value": 0.8 }
            ]
          }
        }
      }
    },
    {
      "title": "Vec Search Candidates Distribution",
      "description": "Average number of candidate vectors returned per search query. This is the 'recall width' — how many concepts the system considers before ranking. More candidates = broader search but slower; fewer = faster but may miss relevant results. Configured via top_k parameter.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 94 },
      "targets": [
        {
          "expr": "rate(qortex_vec_search_candidates_sum[5m]) / rate(qortex_vec_search_candidates_count[5m])",
          "legendFormat": "avg candidates"
        }
      ]
    },
    {
      "title": "Learning & Bandits",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 102 },
      "collapsed": false
    },
    {
      "title": "Selection Rate",
      "description": "Rate of bandit arm selections per second, by learner name and whether it was a baseline (forced exploration) or Thompson Sampling selection. The baseline_rate is configurable (default 10%) and acts as an epsilon-greedy safety net on top of Thompson Sampling's natural exploration. Set baseline_rate=0 for pure TS. High baseline=True rates relative to False indicate the system is still exploring; as posteriors converge, nearly all selections should be baseline=False (exploitation).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 103 },
      "targets": [
        {
          "expr": "rate(qortex_learning_selections_total[5m])",
          "legendFormat": "{{learner}} (baseline={{baseline}})"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Observation Rate",
      "description": "Rate of reward observations by learner and outcome (accepted/rejected/partial). Each observation updates the arm's Beta posterior: accepted adds alpha+1 (reward=1.0), rejected adds beta+1 (reward=0.0), partial adds alpha+0.5/beta+0.5. The reward mapping is pluggable via RewardModel (default: TernaryReward). The caller decides the outcome — qortex doesn't judge, it learns from the signal it's given. A healthy learning system trends toward more 'accepted' over time as the bandit converges on better arms.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 103 },
      "targets": [
        {
          "expr": "rate(qortex_learning_observations_total[5m])",
          "legendFormat": "{{learner}} {{outcome}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Posterior Mean (top 10 arms)",
      "description": "Current posterior mean (alpha / (alpha + beta)) for the top 10 arms by mean value. This IS the learning — each arm has a Beta distribution representing the system's belief about its reward probability. Mean near 1.0 = the system is confident this arm succeeds. Mean near 0.5 = uncertain (not enough data). Mean near 0.0 = confident it fails. Watch the winning arm's line climb toward 1.0 as observations accumulate. Separation between lines shows the bandit is discriminating between good and bad arms.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 111 },
      "targets": [
        {
          "expr": "topk(10, qortex_learning_posterior_mean)",
          "legendFormat": "{{learner}}/{{arm_id}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "short"
        }
      }
    },
    {
      "title": "Token Budget Usage",
      "description": "Distribution of token budget consumed per selection, when a token_budget constraint is set. Each arm has a token_cost (estimated tokens to execute that strategy). The bandit respects the budget: it selects top-ranked arms in order until adding the next one would exceed the budget. p50/p95 show typical vs worst-case budget consumption. Empty if no token_budget is used (the constraint is optional).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 111 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_learning_token_budget_used_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_learning_token_budget_used_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Credit Propagation",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 120 },
      "collapsed": false
    },
    {
      "title": "Credit Propagation Rate",
      "description": "How many times credit has been propagated through the causal DAG per second, by learner. Each propagation fires when qortex_feedback receives outcomes and the credit_propagation flag is enabled. Credit flows backward through the DAG from rewarded concepts to their causal ancestors.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 121 },
      "targets": [
        {
          "expr": "rate(qortex_credit_propagations_total[5m])",
          "legendFormat": "{{learner}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "ops"
        }
      }
    },
    {
      "title": "Concepts per Propagation (p50 / p95)",
      "description": "How many concepts receive credit in each propagation event. Includes both direct concepts (in the rule) and ancestors (upstream in the causal DAG, with decayed credit). Higher counts mean deeper/wider DAGs. p95 spikes indicate large subgraph activations.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 121 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_credit_concepts_per_propagation_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_credit_concepts_per_propagation_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Total Credit Propagations",
      "description": "Lifetime count of credit propagation events since last restart. Confirms the feature is active and firing.",
      "type": "stat",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 4, "w": 8, "x": 0, "y": 130 },
      "targets": [
        {
          "expr": "qortex_credit_propagations_total",
          "legendFormat": "{{learner}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Credit Alpha vs Beta Deltas",
      "description": "Cumulative posterior deltas applied by credit propagation. Alpha deltas come from positive outcomes (accepted) flowing through the causal DAG. Beta deltas come from negative outcomes (rejected). The ratio indicates whether the credit system is reinforcing or penalizing upstream concepts.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 16, "x": 8, "y": 130 },
      "targets": [
        {
          "expr": "qortex_credit_alpha_delta_total",
          "legendFormat": "alpha (success)"
        },
        {
          "expr": "qortex_credit_beta_delta_total",
          "legendFormat": "beta (failure)"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    }
  ],
  "schemaVersion": 39,
  "tags": ["qortex", "observability"],
  "templating": {
    "list": [
      {
        "name": "DS_PROMETHEUS",
        "type": "datasource",
        "query": "prometheus",
        "current": { "text": "Prometheus", "value": "Prometheus" },
        "hide": 2
      }
    ]
  },
  "time": { "from": "now-1h", "to": "now" },
  "timepicker": {},
  "timezone": "",
  "title": "qortex Observability",
  "uid": "qortex-main",
  "version": 1
}
