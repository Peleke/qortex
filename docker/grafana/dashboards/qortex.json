{
  "annotations": { "list": [] },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 1,
  "id": null,
  "links": [],
  "panels": [
    {
      "title": "Retrieval Health",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 0 },
      "collapsed": false
    },
    {
      "title": "Query Rate (queries/sec)",
      "description": "How many retrieval queries qortex is handling per second, broken down by mode (vec = vector-only, graph = GraphRAG with PPR). A healthy system shows steady throughput. Spikes indicate burst traffic; drops may indicate upstream issues or backpressure.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 1 },
      "targets": [
        {
          "expr": "rate(qortex_queries_total[5m])",
          "legendFormat": "{{mode}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "reqps"
        }
      }
    },
    {
      "title": "Query Latency (p50/p95/p99)",
      "description": "End-to-end query latency percentiles. Includes embedding generation, vector search, PPR (if graph mode), and result assembly. p50 is the typical user experience; p95/p99 capture tail latency. If p99 spikes while p50 stays flat, a subset of queries is hitting slow paths (large PPR graphs, cold embeddings).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 1 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_query_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_query_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        },
        {
          "expr": "histogram_quantile(0.99, rate(qortex_query_duration_seconds_bucket[5m]))",
          "legendFormat": "p99"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vec Search Latency (p50/p95)",
      "description": "Latency of the vector similarity search step alone (cosine similarity over the embedding index). This is typically the fastest part of the pipeline. If this spikes, the vector index may need rebuilding or the index has grown too large for in-memory search.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 9 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_vec_search_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_vec_search_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Query Errors",
      "description": "Rate of query failures by pipeline stage: 'embedding' (text-to-vector failed), 'vec_search' (index lookup failed), 'ppr' (PageRank computation failed). Each error emits a QueryFailed event. Non-zero values here mean queries are being dropped — investigate the specific stage.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 9 },
      "targets": [
        {
          "expr": "rate(qortex_query_errors_total[5m])",
          "legendFormat": "{{stage}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Learning Dynamics",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 17 },
      "collapsed": false
    },
    {
      "title": "Factor Mean Over Time",
      "description": "Average teleportation factor across all nodes in the knowledge graph. Teleportation factors control how strongly PPR biases toward specific nodes during random walks. A rising mean indicates the system is learning stronger preferences from feedback; a falling mean suggests uncertainty or conflicting signals.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 18 },
      "targets": [
        {
          "expr": "qortex_factor_mean",
          "legendFormat": "mean factor"
        }
      ]
    },
    {
      "title": "Factor Entropy",
      "description": "Shannon entropy of the teleportation factor distribution. High entropy = factors are spread evenly (the system hasn't formed strong opinions yet). Low entropy = factors are concentrated on a few nodes (the system has learned clear preferences). Entropy should decrease over time as the system accumulates feedback.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 18 },
      "targets": [
        {
          "expr": "qortex_factor_entropy",
          "legendFormat": "entropy"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "bits"
        }
      }
    },
    {
      "title": "Factor Update Rate",
      "description": "How frequently teleportation factors are being updated, by feedback outcome (accepted/rejected/partial). Each update adjusts how PPR weights specific nodes. High update rates indicate active learning; the balance of accepted vs rejected shows whether the system's suggestions are landing.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 18 },
      "targets": [
        {
          "expr": "rate(qortex_factor_updates_total[5m])",
          "legendFormat": "{{outcome}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Feedback Accept/Reject Ratio",
      "description": "Rate of user/system feedback events classified as accepted vs rejected. This is the raw signal that drives all learning in qortex — both teleportation factor updates and bandit posterior updates. A healthy system trends toward more accepts over time as learning kicks in. A sustained high rejection rate may indicate poor initial candidates or a domain mismatch.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 26 },
      "targets": [
        {
          "expr": "rate(qortex_feedback_total{outcome=\"accepted\"}[5m])",
          "legendFormat": "accepted"
        },
        {
          "expr": "rate(qortex_feedback_total{outcome=\"rejected\"}[5m])",
          "legendFormat": "rejected"
        }
      ]
    },
    {
      "title": "KG Crystallization",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 34 },
      "collapsed": false
    },
    {
      "title": "KG Coverage Ratio",
      "description": "Fraction of the knowledge graph that has been 'covered' by online edges (runtime-discovered relationships). 0% = no runtime edges, purely static graph. 100% = every node has at least one online edge. Coverage above 70% (green) indicates the system has explored most of the graph through real usage.",
      "type": "gauge",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 35 },
      "targets": [
        {
          "expr": "qortex_kg_coverage",
          "legendFormat": "coverage"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit",
          "thresholds": {
            "steps": [
              { "color": "red", "value": null },
              { "color": "yellow", "value": 0.3 },
              { "color": "green", "value": 0.7 }
            ]
          }
        }
      }
    },
    {
      "title": "Buffer Size & Promotions",
      "description": "Online edges live in a buffer before being promoted to the persistent knowledge graph. 'Buffered' shows how many edges are waiting; 'promotions/hr' shows how fast they're graduating. A growing buffer with no promotions means edges aren't meeting the confidence threshold for persistence.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 35 },
      "targets": [
        {
          "expr": "qortex_buffer_edges",
          "legendFormat": "buffered"
        },
        {
          "expr": "rate(qortex_edges_promoted_total[1h])",
          "legendFormat": "promotions/hr"
        }
      ]
    },
    {
      "title": "Total Promoted (lifetime)",
      "description": "Cumulative count of online edges that have been promoted from the buffer into the persistent knowledge graph. This is the system's 'crystallized learning' — relationships it discovered at runtime and deemed confident enough to keep permanently.",
      "type": "stat",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 35 },
      "targets": [
        {
          "expr": "qortex_edges_promoted_total",
          "legendFormat": "total promoted"
        }
      ]
    },
    {
      "title": "PPR Performance",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 43 },
      "collapsed": false
    },
    {
      "title": "PPR Executions / sec",
      "description": "Rate of Personalized PageRank computations. Each graph-mode query triggers one PPR run, which performs power iteration over the knowledge graph to rank nodes by relevance. More PPR runs = more graph-mode queries being served.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 44 },
      "targets": [
        {
          "expr": "rate(qortex_ppr_started_total[5m])",
          "legendFormat": "PPR runs/sec"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "PPR Iterations to Convergence",
      "description": "Distribution of how many power-iteration steps PPR needs before the score vector stabilizes (within tolerance). Fewer iterations = faster convergence = simpler graph structure. If many runs cluster at the maximum (100), the graph may have pathological structure or the tolerance is too tight.",
      "type": "histogram",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 44 },
      "targets": [
        {
          "expr": "rate(qortex_ppr_iterations_bucket[5m])",
          "legendFormat": "{{le}}"
        }
      ]
    },
    {
      "title": "Active Factors & Node Count",
      "description": "Number of nodes in the knowledge graph that have non-default teleportation factors. These are nodes the system has formed an opinion about based on feedback. Growing = the system is learning about more of the graph. Flat = no new feedback is reaching new nodes.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 44 },
      "targets": [
        {
          "expr": "qortex_factors_active",
          "legendFormat": "active factors"
        }
      ]
    },
    {
      "title": "Online Edge Generation",
      "description": "How many online edges are being generated per query (edges/query) and the overall event rate (events/sec). Online edges are runtime-discovered relationships between concepts, inferred from co-occurrence in query results. More edges per query = richer associative structure being captured.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 52 },
      "targets": [
        {
          "expr": "qortex_online_edge_count",
          "legendFormat": "edges / query"
        },
        {
          "expr": "rate(qortex_online_edges_generated_total[5m])",
          "legendFormat": "generation events / sec"
        }
      ]
    },
    {
      "title": "KG Coverage Over Time",
      "description": "Time series of knowledge graph coverage. Shows how the graph's explored territory grows as the system processes queries. Monotonically increasing in a healthy system. Plateaus indicate the system has explored most reachable nodes; jumps indicate new domains or concept batches being ingested.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 52 },
      "targets": [
        {
          "expr": "qortex_kg_coverage",
          "legendFormat": "coverage"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit"
        }
      }
    },
    {
      "title": "Enrichment & Ingestion",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 60 },
      "collapsed": false
    },
    {
      "title": "Enrichment Rate",
      "description": "Rate of LLM enrichment calls by backend type. Enrichment uses an LLM to extract structured relationships from raw text when ingesting new concepts. Higher rates mean more content is being processed. The backend_type label distinguishes different LLM providers (openai, anthropic, local).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 61 },
      "targets": [
        {
          "expr": "rate(qortex_enrichment_total[5m])",
          "legendFormat": "{{backend_type}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Enrichment Latency (p50/p95)",
      "description": "How long LLM enrichment calls take. This is dominated by the LLM's response time. p50 is the typical call; p95 captures retries and long-context extractions. If p95 is significantly higher than p50, some documents are much harder to enrich than others.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 61 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_enrichment_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_enrichment_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Enrichment Fallbacks",
      "description": "Rate of enrichment fallbacks — when the primary LLM backend fails and the system falls back to a simpler extraction method. Non-zero rates here mean the LLM is unreliable; consistently high rates may warrant switching providers or increasing timeouts.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 61 },
      "targets": [
        {
          "expr": "rate(qortex_enrichment_fallbacks_total[5m])",
          "legendFormat": "fallbacks/sec"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Ingestion Rate",
      "description": "Rate of manifest ingestion events by domain. A manifest is a batch of concepts being added to the knowledge graph. Each domain (e.g. 'prompts', 'code', 'docs') tracks independently. Spikes indicate bulk imports; steady rates indicate continuous ingestion pipelines.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 69 },
      "targets": [
        {
          "expr": "rate(qortex_manifests_ingested_total[5m])",
          "legendFormat": "{{domain}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Ingest Latency (p50/p95)",
      "description": "Time taken to ingest a manifest (create nodes, generate embeddings, add to vector index, insert edges). Includes all backend writes. Latency depends on manifest size and backend type (InMemory is fast, Memgraph adds network round-trips).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 69 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_ingest_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_ingest_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vector Index",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 77 },
      "collapsed": false
    },
    {
      "title": "Vec Index Size",
      "description": "Total number of embedding vectors stored in the index. Each concept in the knowledge graph has one vector. This is the system's 'memory size' — how many concepts it can search over. Growth indicates new concepts being ingested.",
      "type": "stat",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 6, "x": 0, "y": 78 },
      "targets": [
        {
          "expr": "qortex_vec_index_size",
          "legendFormat": "vectors"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Add Rate",
      "description": "Rate of vectors being added to the index, by index type (numpy = in-memory, or external). Each add operation embeds a concept and inserts it into the searchable index. Correlates with ingestion rate but can differ if concepts are updated (re-embedded).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 9, "x": 6, "y": 78 },
      "targets": [
        {
          "expr": "rate(qortex_vec_add_total[5m])",
          "legendFormat": "{{index_type}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "ops"
        }
      }
    },
    {
      "title": "Vec Add Latency (p50/p95)",
      "description": "Time to insert a vector into the index. For NumpyVectorIndex this is a fast array append. For external indices (future: FAISS, pgvector), this includes network overhead. Sub-millisecond is healthy for in-memory.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 9, "x": 15, "y": 78 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_vec_add_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_vec_add_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vec Search Top Score",
      "description": "Cosine similarity of the best-matching vector in the most recent search. Range 0-1, where 1.0 = exact match. Scores above 0.8 indicate strong semantic matches. Consistently low scores (< 0.5) suggest the query domain isn't well-represented in the index — more relevant concepts may need to be ingested.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 0, "y": 86 },
      "targets": [
        {
          "expr": "qortex_vec_search_top_score",
          "legendFormat": "top score"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Search Score Spread",
      "description": "Difference between the highest and lowest cosine similarity scores in the most recent search results. A large spread means the top result is much more relevant than the bottom result (good discrimination). A narrow spread means all candidates scored similarly (the query is either too generic or too specific).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 8, "y": 86 },
      "targets": [
        {
          "expr": "qortex_vec_search_score_spread",
          "legendFormat": "spread"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Seed Yield",
      "description": "Ratio of vector search results that survive domain filtering. Yield of 1.0 = all results were in the requested domain. Yield of 0.3 = 70% of results were filtered out because they belonged to other domains. Low yield means the index is dominated by other domains; consider domain-specific indices.",
      "type": "gauge",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 8, "x": 16, "y": 86 },
      "targets": [
        {
          "expr": "qortex_vec_seed_yield",
          "legendFormat": "yield"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit",
          "thresholds": {
            "steps": [
              { "color": "red", "value": null },
              { "color": "yellow", "value": 0.5 },
              { "color": "green", "value": 0.8 }
            ]
          }
        }
      }
    },
    {
      "title": "Vec Search Candidates Distribution",
      "description": "Average number of candidate vectors returned per search query. This is the 'recall width' — how many concepts the system considers before ranking. More candidates = broader search but slower; fewer = faster but may miss relevant results. Configured via top_k parameter.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 94 },
      "targets": [
        {
          "expr": "rate(qortex_vec_search_candidates_sum[5m]) / rate(qortex_vec_search_candidates_count[5m])",
          "legendFormat": "avg candidates"
        }
      ]
    },
    {
      "title": "Learning & Bandits",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 102 },
      "collapsed": false
    },
    {
      "title": "",
      "type": "text",
      "gridPos": { "h": 7, "w": 24, "x": 0, "y": 103 },
      "options": {
        "mode": "markdown",
        "content": "## Thompson Sampling Bandit\n\nqortex learns which strategies work by modeling each **arm** (candidate action) as a Beta distribution.\nEvery outcome updates the posterior: `accepted` reinforces, `rejected` penalizes, `partial` hedges.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Selection Rate** | Selections/sec by learner | Steady flow, baseline rate decreasing over time | Flat baseline=True means posteriors aren't separating |\n| **Observation Rate** | Outcomes by type | `accepted` trending up as bandit converges | Persistent `rejected` majority means bad arm pool or noisy signal |\n| **Posterior Mean** | Top 10 arms ranked by confidence | Clear winner pulling away from the pack | All arms clustered at 0.5 = insufficient data or no real signal |\n| **Token Budget** | Budget consumed per selection | p50 well under limit, p95 occasional spikes | p95 consistently at budget cap = arms are too expensive |\n\n`baseline_rate` (default 10%) forces random exploration on top of Thompson Sampling's natural explore/exploit.\nSet to 0 for pure TS. Watch the baseline=True line shrink as the system gets confident.\n\n```\nDogfood: uv run python scripts/demo_learning_live.py\n```"
      },
      "transparent": true
    },
    {
      "title": "Selection Rate",
      "description": "Rate of bandit arm selections per second, by learner name and whether it was a baseline (forced exploration) or Thompson Sampling selection.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 110 },
      "targets": [
        {
          "expr": "rate(qortex_learning_selections_total[5m])",
          "legendFormat": "{{learner}} (baseline={{baseline}})"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Observation Rate",
      "description": "Rate of reward observations by learner and outcome (accepted/rejected/partial).",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 110 },
      "targets": [
        {
          "expr": "rate(qortex_learning_observations_total[5m])",
          "legendFormat": "{{learner}} {{outcome}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Posterior Mean (top 10 arms)",
      "description": "Current posterior mean (alpha / (alpha + beta)) for the top 10 arms. This IS the learning. Mean near 1.0 = confident success. 0.5 = uncertain. 0.0 = confident failure.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 118 },
      "targets": [
        {
          "expr": "topk(10, qortex_learning_posterior_mean)",
          "legendFormat": "{{learner}}/{{arm_id}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "short"
        }
      }
    },
    {
      "title": "Token Budget Usage",
      "description": "Token budget consumed per selection (p50/p95). Empty if no token_budget constraint is set.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 118 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_learning_token_budget_used_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_learning_token_budget_used_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Credit Propagation",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 127 },
      "collapsed": false
    },
    {
      "title": "",
      "type": "text",
      "gridPos": { "h": 8, "w": 24, "x": 0, "y": 128 },
      "options": {
        "mode": "markdown",
        "content": "## Causal Credit Assignment\n\nWhen a user gives feedback (`accepted` / `rejected` / `partial`), credit propagates **backward** through the causal DAG to upstream concepts.\n\n```mermaid\nflowchart BT\n    F[\"foundations\"] -->|strength: 0.95| A[\"algebra\"]\n    A -->|strength: 0.85| LA[\"linear-algebra\"]\n    style LA fill:#2d6a4f,stroke:#40916c,color:#d8f3dc\n    style A fill:#1b4332,stroke:#40916c,color:#b7e4c7\n    style F fill:#081c15,stroke:#2d6a4f,color:#95d5b2\n```\n\n| Concept | Method | Credit Math | Posterior Update |\n|---------|--------|-------------|------------------|\n| **linear-algebra** | direct | `1.0` | `alpha += 1.0` |\n| **algebra** | ancestor (1 hop) | `1.0 x 0.5 x 0.85` = 0.425 | `alpha += 0.425` |\n| **foundations** | ancestor (2 hops) | `0.425 x 0.5 x 0.95` = 0.202 | `alpha += 0.202` |\n\nDecays `0.5x` per hop, weighted by edge strength. Negative outcomes push `beta` instead of `alpha`.\n\n| Signal | Healthy | Investigate |\n|--------|---------|-------------|\n| **Propagation Rate** | Matches feedback rate | Zero while feedback flows = flag off or empty DAG |\n| **Concepts/Propagation** | p50 of 3-5 | p50=1 = no ancestor credit (disconnected DAG) |\n| **Total Propagations** | Monotonically increasing | Stuck at 0 = feature not active |\n| **Alpha vs Beta** | Alpha ahead = net positive signal | Beta dominating = users rejecting results |\n\nRequires `QORTEX_CREDIT_PROPAGATION=on` or `credit_propagation: true` in `~/.qortex/flags.yaml`.\nDogfood: `uv run python scripts/demo_credit_propagation_live.py`"
      },
      "transparent": true
    },
    {
      "title": "Credit Propagation Rate",
      "description": "Propagations/sec through the causal DAG, by learner.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 136 },
      "targets": [
        {
          "expr": "rate(qortex_credit_propagations_total[5m])",
          "legendFormat": "{{learner}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "ops"
        }
      }
    },
    {
      "title": "Concepts per Propagation (p50 / p95)",
      "description": "How many concepts receive credit per event. Direct + ancestors. Higher = deeper DAG activation.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 136 },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_credit_concepts_per_propagation_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_credit_concepts_per_propagation_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Total Credit Propagations",
      "description": "Lifetime propagation count since restart.",
      "type": "stat",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 4, "w": 8, "x": 0, "y": 144 },
      "targets": [
        {
          "expr": "qortex_credit_propagations_total",
          "legendFormat": "{{learner}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Credit Alpha vs Beta Deltas",
      "description": "Cumulative success (alpha) vs failure (beta) signal from credit propagation.",
      "type": "timeseries",
      "datasource": { "type": "prometheus", "uid": "${DS_PROMETHEUS}" },
      "gridPos": { "h": 8, "w": 16, "x": 8, "y": 144 },
      "targets": [
        {
          "expr": "qortex_credit_alpha_delta_total",
          "legendFormat": "alpha (success)"
        },
        {
          "expr": "qortex_credit_beta_delta_total",
          "legendFormat": "beta (failure)"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    }
  ],
  "schemaVersion": 39,
  "tags": ["qortex", "observability"],
  "templating": {
    "list": [
      {
        "name": "DS_PROMETHEUS",
        "type": "datasource",
        "query": "prometheus",
        "current": { "text": "Prometheus", "value": "Prometheus" },
        "hide": 2
      }
    ]
  },
  "time": { "from": "now-1h", "to": "now" },
  "timepicker": {},
  "timezone": "",
  "title": "qortex Observability",
  "uid": "qortex-main",
  "version": 1
}
