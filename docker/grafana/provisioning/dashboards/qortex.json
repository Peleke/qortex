{
  "annotations": {
    "list": []
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 1,
  "id": null,
  "links": [],
  "panels": [
    {
      "title": "Embedding Index",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "collapsed": false
    },
    {
      "title": "Search Pipeline",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 1
      },
      "options": {
        "content": "flowchart LR\n    C(\"Concept\") --> EMB(\"Embed\")\n    EMB --> IDX(\"Vector\\nIndex\")\n    IDX -->|\"cosine sim\"| TOP(\"Top-K\\nCandidates\")\n    TOP -->|\"domain filter\"| RES(\"Filtered\\nResults\")\n    style C fill:#003049,stroke:#d62828,color:#fcbf49,stroke-width:2px\n    style EMB fill:#d62828,stroke:#f77f00,color:#fcbf49,stroke-width:2px\n    style IDX fill:#f77f00,stroke:#fcbf49,color:#003049,stroke-width:2px\n    style TOP fill:#fcbf49,stroke:#eae2b7,color:#003049,stroke-width:2px\n    style RES fill:#eae2b7,stroke:#eae2b7,color:#003049,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#f77f00\",\"lineColor\":\"#fcbf49\",\"textColor\":\"#fcbf49\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 9
      },
      "options": {
        "mode": "markdown",
        "content": "## Vector Index\n\nEvery concept is embedded into a vector and stored in the index. Queries are embedded the same way, then matched via **cosine similarity**.\nTop-K candidates are retrieved, then filtered by domain. The **seed yield** measures how many survive domain filtering.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Index Size** | Total vectors stored | Growing with ingestion | Flat = no new concepts being added |\n| **Add Rate/Latency** | Insert perf by index type | Sub-ms for numpy (in-memory) | Spikes = index rebuild or backend lag |\n| **Top Score** | Best cosine similarity | > 0.8 for strong matches | Consistently < 0.5 = domain not represented |\n| **Score Spread** | Max \u2212 min score gap | Large = good discrimination | Narrow = query too generic or too specific |\n| **Seed Yield** | Survive domain filter | > 80% (green) | < 50% = index dominated by other domains |"
      },
      "transparent": true
    },
    {
      "title": "Vec Index Size",
      "description": "Total number of embedding vectors stored in the index. Each concept in the knowledge graph has one vector. This is the system's 'memory size' \u2014 how many concepts it can search over. Growth indicates new concepts being ingested.",
      "type": "stat",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 6,
        "x": 0,
        "y": 17
      },
      "targets": [
        {
          "expr": "sum(qortex_vec_index_size)",
          "legendFormat": "vectors"
        }
      ],
      "options": {
        "graphMode": "none"
      },
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Adds (total & recent)",
      "description": "Vectors added to the index by type. Shows raw total (always visible) and per-interval increase. At dev scale, the total is what matters.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 9,
        "x": 6,
        "y": 25
      },
      "targets": [
        {
          "expr": "sum by (index_type) (qortex_vec_add_total)",
          "legendFormat": "total ({{index_type}})"
        },
        {
          "expr": "sum by (index_type) (increase(qortex_vec_add_total[$__rate_interval]))",
          "legendFormat": "recent ({{index_type}})"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Add Latency (avg / p50 / p95)",
      "description": "Time to insert a vector. Shows avg (always visible if any adds happened) plus quantiles from a 15m window. Sub-ms is healthy for sqlite-vec.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 9,
        "x": 15,
        "y": 33
      },
      "targets": [
        {
          "expr": "sum(qortex_vec_add_duration_seconds_sum) / sum(qortex_vec_add_duration_seconds_count)",
          "legendFormat": "avg"
        },
        {
          "expr": "histogram_quantile(0.50, sum(increase(qortex_vec_add_duration_seconds_bucket[15m])) by (le))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, sum(increase(qortex_vec_add_duration_seconds_bucket[15m])) by (le))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vec Search Top Score",
      "description": "Cosine similarity of the best-matching vector in the most recent search. Range 0-1, where 1.0 = exact match. Scores above 0.8 indicate strong semantic matches. Consistently low scores (< 0.5) suggest the query domain isn't well-represented in the index \u2014 more relevant concepts may need to be ingested.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 41
      },
      "targets": [
        {
          "expr": "max(qortex_vec_search_top_score)",
          "legendFormat": "top score"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Search Score Spread",
      "description": "Difference between the highest and lowest cosine similarity scores in the most recent search results. A large spread means the top result is much more relevant than the bottom result (good discrimination). A narrow spread means all candidates scored similarly (the query is either too generic or too specific).",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 8,
        "y": 49
      },
      "targets": [
        {
          "expr": "max(qortex_vec_search_score_spread)",
          "legendFormat": "spread"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "unit": "short"
        }
      }
    },
    {
      "title": "Vec Seed Yield",
      "description": "Ratio of vector search results that survive domain filtering. Yield of 1.0 = all results were in the requested domain. Yield of 0.3 = 70% of results were filtered out because they belonged to other domains. Low yield means the index is dominated by other domains; consider domain-specific indices.",
      "type": "gauge",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 16,
        "y": 57
      },
      "targets": [
        {
          "expr": "max(qortex_vec_seed_yield)",
          "legendFormat": "yield"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit",
          "thresholds": {
            "steps": [
              {
                "color": "red",
                "value": null
              },
              {
                "color": "yellow",
                "value": 0.5
              },
              {
                "color": "green",
                "value": 0.8
              }
            ]
          }
        }
      }
    },
    {
      "title": "Vec Search Candidates Distribution",
      "description": "Average number of candidate vectors returned per search query. This is the 'recall width' \u2014 how many concepts the system considers before ranking. More candidates = broader search but slower; fewer = faster but may miss relevant results. Configured via top_k parameter.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 65
      },
      "targets": [
        {
          "expr": "rate(qortex_vec_search_candidates_sum[5m]) / rate(qortex_vec_search_candidates_count[5m])",
          "legendFormat": "avg candidates"
        }
      ]
    },
    {
      "title": "Bandit Arms & Selections",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 73
      },
      "collapsed": false
    },
    {
      "title": "Bandit Loop",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 7,
        "w": 8,
        "x": 0,
        "y": 74
      },
      "options": {
        "content": "flowchart LR\n    POOL(\"Arm Pool\\nBeta(\u03b1,\u03b2)\") -->|\"Thompson\\nSample\"| SEL(\"Select\\nArm\")\n    SEL --> ACT(\"Execute\")\n    ACT --> OUT(\"Observe\\nOutcome\")\n    OUT -->|\"\u03b1++ or \u03b2++\"| POOL\n    style POOL fill:#1b4332,stroke:#40916c,color:#d8f3dc,stroke-width:2px\n    style SEL fill:#2d6a4f,stroke:#52b788,color:#d8f3dc,stroke-width:2px\n    style ACT fill:#40916c,stroke:#95d5b2,color:#d8f3dc,stroke-width:2px\n    style OUT fill:#52b788,stroke:#d8f3dc,color:#1b4332,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#2d6a4f\",\"lineColor\":\"#40916c\",\"textColor\":\"#d8f3dc\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 7,
        "w": 16,
        "x": 8,
        "y": 81
      },
      "options": {
        "mode": "markdown",
        "content": "## Thompson Sampling Bandit\n\nqortex learns which strategies work by modeling each **arm** (candidate action) as a Beta distribution.\nEvery outcome updates the posterior: `accepted` reinforces, `rejected` penalizes, `partial` hedges.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Selection Rate** | Selections/sec by learner | Steady flow, baseline rate decreasing over time | Flat baseline=True means posteriors aren't separating |\n| **Observation Rate** | Outcomes by type | `accepted` trending up as bandit converges | Persistent `rejected` majority means bad arm pool or noisy signal |\n| **Posterior Mean** | Top 10 arms ranked by confidence | Clear winner pulling away from the pack | All arms clustered at 0.5 = insufficient data or no real signal |\n| **Token Budget** | Budget consumed per selection | p50 well under limit, p95 occasional spikes | p95 consistently at budget cap = arms are too expensive |\n\n`baseline_rate` (default 10%) forces random exploration on top of Thompson Sampling's natural explore/exploit.\nSet to 0 for pure TS. Watch the baseline=True line shrink as the system gets confident.\n\n```\nDogfood: uv run python scripts/demo_learning_live.py\n```"
      },
      "transparent": true
    },
    {
      "title": "Feedback Loop",
      "description": "How selected tools performed. Accepted = tool output used. Rejected = output discarded. The ratio shows whether the system is picking winners. Accepted should dominate over time.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 24,
        "x": 0,
        "y": 88
      },
      "targets": [
        {
          "expr": "sum(increase(qortex_learning_observations_total{outcome=\"accepted\"}[$__rate_interval]))",
          "legendFormat": "accepted"
        },
        {
          "expr": "sum(increase(qortex_learning_observations_total{outcome=\"rejected\"}[$__rate_interval]))",
          "legendFormat": "rejected"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "custom": {
            "drawStyle": "bars",
            "stacking": {
              "mode": "normal"
            }
          },
          "unit": "short"
        },
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "accepted"
            },
            "properties": [
              {
                "id": "color",
                "value": {
                  "fixedColor": "green",
                  "mode": "fixed"
                }
              }
            ]
          },
          {
            "matcher": {
              "id": "byName",
              "options": "rejected"
            },
            "properties": [
              {
                "id": "color",
                "value": {
                  "fixedColor": "red",
                  "mode": "fixed"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "title": "Tool Quality (posterior mean)",
      "description": "The system's confidence in each tool. 1.0 = always works. 0.0 = never works. Watch these separate over time \u2014 the system learns which tools produce accepted output and favors them.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 96
      },
      "targets": [
        {
          "expr": "topk(10, max by (arm_id) (qortex_learning_posterior_mean))",
          "legendFormat": "{{arm_id}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit"
        }
      }
    },
    {
      "title": "Arm Pulls",
      "description": "How many times each tool has been tried. Even distribution early (exploring). Skewed toward winners later (exploiting). The separation between these curves IS the learning signal.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 104
      },
      "targets": [
        {
          "expr": "topk(10, sum by (arm_id) (qortex_learning_arm_pulls_total))",
          "legendFormat": "{{arm_id}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Poisoning Detection",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 7,
        "w": 12,
        "x": 0,
        "y": 112
      },
      "options": {
        "content": "flowchart LR\n    CT[\"Conversational\\nTurn\"] -->|no tools| SKIP[\"Skip\\nObservation\"]\n    MT[\"Meta-tool\\nOnly\"] -->|no real tools| SKIP\n    RT[\"Real Tool\\nUsage\"] -->|observe| OBS[\"Record\\nOutcome\"]\n    OBS -->|accepted| UP[\"alpha += 1\"]\n    OBS -->|rejected| DOWN[\"beta += 1\"]\n    SKIP -.->|\"POISON FIX\"| X(\" \")\n    style SKIP fill:#2d6a4f,stroke:#40916c,color:#d8f3dc,stroke-width:2px\n    style X fill:none,stroke:none\n    style CT fill:#1b4332,stroke:#40916c,color:#b7e4c7\n    style MT fill:#1b4332,stroke:#40916c,color:#b7e4c7\n    style RT fill:#081c15,stroke:#2d6a4f,color:#95d5b2\n    style UP fill:#2d6a4f,stroke:#40916c,color:#d8f3dc\n    style DOWN fill:#9b2226,stroke:#ae2012,color:#ffddd2\n    style OBS fill:#1b4332,stroke:#40916c,color:#b7e4c7",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#2d6a4f\",\"lineColor\":\"#40916c\",\"textColor\":\"#d8f3dc\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 7,
        "w": 12,
        "x": 12,
        "y": 119
      },
      "options": {
        "mode": "markdown",
        "content": "## Poisoning Detection & Recovery\n\nThe three-tier observation guard prevents **bandit self-poisoning** \u2014 where conversational turns\n(no tool use) were incorrectly recorded as rejection of ALL arms, collapsing posteriors to `Beta(1, N)`.\n\n| Signal | What to watch | Healthy | Poisoned |\n|--------|--------------|---------|----------|\n| **Bottom 10 Posterior** | Worst-performing arms | Gradually separating from 0.5 as real data flows | All arms crushed near 0.0 with low pull count |\n| **Raw Alpha** | Success count per arm | Growing with accepted observations | Stuck at 1 (prior) while beta climbs |\n| **Raw Beta** | Failure count per arm | Growing slower than alpha for good arms | `beta >> alpha` with `pulls < 50` = poisoning signature |\n| **Beta/Alpha Ratio** | Failure-to-success ratio | < 3.0 for most arms | > 10.0 with low pulls = false rejections |\n\n**Poisoning signature**: `beta > 10 * alpha AND pulls < 50` on any arm.\n**Recovery**: Reset bandit state via the `/reward` endpoint, then verify bottom arms climb back toward 0.5."
      },
      "transparent": true
    },
    {
      "title": "Posterior Mean (bottom 10 arms)",
      "description": "Current posterior mean for the bottom 10 arms \u2014 the ones most likely to be poisoned or genuinely bad. During recovery, watch these climb from near-0 back toward 0.5 (uniform prior).",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 126
      },
      "targets": [
        {
          "expr": "bottomk(10, max by (learner, arm_id) (qortex_learning_posterior_mean))",
          "legendFormat": "{{learner}}/{{arm_id}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "short",
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "lineWidth": 2,
            "fillOpacity": 10
          }
        },
        "overrides": [
          {
            "matcher": {
              "id": "byRegexp",
              "options": ".*"
            },
            "properties": [
              {
                "id": "thresholds",
                "value": {
                  "mode": "absolute",
                  "steps": [
                    {
                      "color": "red",
                      "value": null
                    },
                    {
                      "color": "orange",
                      "value": 0.1
                    },
                    {
                      "color": "green",
                      "value": 0.3
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    },
    {
      "title": "Raw Alpha (top 10 by beta/alpha ratio)",
      "description": "Raw alpha (success) and beta (failure) for arms with the worst beta/alpha ratio \u2014 the poisoning signature. Healthy arms have alpha growing faster than beta.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 134
      },
      "targets": [
        {
          "expr": "topk(10, max by (learner, arm_id) (qortex_learning_arm_beta) / max by (learner, arm_id) (qortex_learning_arm_alpha))",
          "legendFormat": "\u03b2/\u03b1 {{learner}}/{{arm_id}}"
        },
        {
          "expr": "max by (learner, arm_id) (qortex_learning_arm_alpha) * on(learner, arm_id) group_left topk(10, max by (learner, arm_id) (qortex_learning_arm_beta) / max by (learner, arm_id) (qortex_learning_arm_alpha))",
          "legendFormat": "\u03b1 {{learner}}/{{arm_id}}",
          "hide": true
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short",
          "custom": {
            "lineWidth": 2,
            "fillOpacity": 5
          }
        }
      }
    },
    {
      "title": "Poisoning Canary",
      "description": "Number of arms where beta > 10*alpha AND pulls < 50. Should be 0 after the three-tier observation guard is active. Any value > 0 means false rejections are flowing.",
      "type": "stat",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 4,
        "w": 12,
        "x": 0,
        "y": 142
      },
      "targets": [
        {
          "expr": "count(max by (learner, arm_id) (qortex_learning_arm_beta) > 10 * max by (learner, arm_id) (qortex_learning_arm_alpha) and max by (learner, arm_id) (qortex_learning_arm_pulls) < 50) or vector(0)",
          "legendFormat": "poisoned arms"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short",
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 1
              }
            ]
          },
          "color": {
            "mode": "thresholds"
          }
        }
      },
      "options": {
        "colorMode": "background",
        "graphMode": "none",
        "textMode": "value_and_name",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ]
        }
      }
    },
    {
      "title": "Arm Pull Count (bottom 10)",
      "description": "Total observations per arm for the least-pulled arms. Arms with very few pulls but collapsed posteriors = poisoning. Arms with many pulls and low mean = genuinely bad.",
      "type": "bargauge",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 4,
        "w": 12,
        "x": 12,
        "y": 146
      },
      "targets": [
        {
          "expr": "bottomk(10, sum by (arm_id) (qortex_learning_arm_pulls))",
          "legendFormat": "{{arm_id}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short",
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "red",
                "value": null
              },
              {
                "color": "yellow",
                "value": 10
              },
              {
                "color": "green",
                "value": 50
              }
            ]
          },
          "color": {
            "mode": "thresholds"
          }
        }
      },
      "options": {
        "orientation": "horizontal",
        "displayMode": "gradient",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ]
        }
      }
    },
    {
      "title": "Knowledge Graph Growth",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 150
      },
      "collapsed": false
    },
    {
      "title": "Edge Lifecycle",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 151
      },
      "options": {
        "content": "flowchart LR\n    QR(\"Query\\nResults\") --> OE(\"Online\\nEdges\")\n    OE --> BUF(\"Buffer\")\n    BUF -->|\"confidence\\nthreshold\"| KG(\"Persistent\\nKG\")\n    BUF -.->|\"evict\"| X(\"Discard\")\n    style QR fill:#1b2838,stroke:#2a475e,color:#66c0f4,stroke-width:2px\n    style OE fill:#2a475e,stroke:#3d6b8e,color:#66c0f4,stroke-width:2px\n    style BUF fill:#3d6b8e,stroke:#66c0f4,color:#1b2838,stroke-width:2px\n    style KG fill:#66c0f4,stroke:#66c0f4,color:#1b2838,stroke-width:2px\n    style X fill:#4a4a4a,stroke:#666,color:#999,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#2a475e\",\"lineColor\":\"#66c0f4\",\"textColor\":\"#66c0f4\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 159
      },
      "options": {
        "mode": "markdown",
        "content": "## KG Crystallization\n\nRuntime queries discover relationships (**online edges**) between co-occurring concepts. Edges enter a **buffer**\nand graduate to the persistent KG once confidence exceeds the promotion threshold. This is how the graph grows organically from usage.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Coverage Ratio** | % of nodes with online edges | > 70% (green) | < 30% = graph barely explored |\n| **Buffer Size** | Edges waiting for promotion | Growing with usage, draining via promotions | Growing with zero promotions = threshold too high |\n| **Promotions** | Edges graduating/hr | Steady flow | Zero = edges never meet confidence threshold |\n| **Total Promoted** | Lifetime crystallized edges | Monotonically increasing | Stuck at 0 = feature not active |"
      },
      "transparent": true
    },
    {
      "title": "Graph Nodes",
      "description": "Total Concept nodes created in the knowledge graph from online indexing (conversation messages) and manifest ingestion. This is the absolute size of the graph's node set.",
      "type": "stat",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 6,
        "w": 6,
        "x": 0,
        "y": 167
      },
      "targets": [
        {
          "expr": "sum(qortex_graph_nodes_created_total)",
          "legendFormat": "nodes"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "fixed",
            "fixedColor": "#66c0f4"
          }
        }
      }
    },
    {
      "title": "Graph Edges",
      "description": "Total edges created in the knowledge graph from co-occurrence linking and manifest ingestion. This is the absolute size of the graph's edge set.",
      "type": "stat",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 6,
        "w": 6,
        "x": 6,
        "y": 173
      },
      "targets": [
        {
          "expr": "sum(qortex_graph_edges_created_total)",
          "legendFormat": "edges"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "fixed",
            "fixedColor": "#a3d977"
          }
        }
      }
    },
    {
      "title": "Graph Growth (cumulative)",
      "description": "Cumulative nodes and edges created in the knowledge graph over time. Shows how the graph grows from conversation ingestion and manifest loads.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 6,
        "w": 12,
        "x": 12,
        "y": 179
      },
      "targets": [
        {
          "expr": "sum(qortex_graph_nodes_created_total)",
          "legendFormat": "nodes"
        },
        {
          "expr": "sum(qortex_graph_edges_created_total)",
          "legendFormat": "edges"
        }
      ]
    },
    {
      "title": "Nodes by Origin",
      "description": "Cumulative node creation broken down by origin: online_index (conversation messages) vs manifest (bulk ingestion).",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 6,
        "w": 12,
        "x": 0,
        "y": 185
      },
      "targets": [
        {
          "expr": "sum by (origin) (qortex_graph_nodes_created_total)",
          "legendFormat": "{{origin}}"
        }
      ]
    },
    {
      "title": "Edges by Origin",
      "description": "Cumulative edge creation broken down by origin: co_occurrence (consecutive chunk linking) vs manifest (bulk ingestion).",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 6,
        "w": 12,
        "x": 12,
        "y": 191
      },
      "targets": [
        {
          "expr": "sum by (origin) (qortex_graph_edges_created_total)",
          "legendFormat": "{{origin}}"
        }
      ]
    },
    {
      "title": "KG Coverage Ratio",
      "description": "Fraction of the knowledge graph that has been 'covered' by online edges (runtime-discovered relationships). 0% = no runtime edges, purely static graph. 100% = every node has at least one online edge. Coverage above 70% (green) indicates the system has explored most of the graph through real usage.",
      "type": "gauge",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 197
      },
      "targets": [
        {
          "expr": "max(qortex_kg_coverage)",
          "legendFormat": "coverage"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit",
          "thresholds": {
            "steps": [
              {
                "color": "red",
                "value": null
              },
              {
                "color": "yellow",
                "value": 0.3
              },
              {
                "color": "green",
                "value": 0.7
              }
            ]
          }
        }
      }
    },
    {
      "title": "Buffer Size & Promotions",
      "description": "Online edges live in a buffer before being promoted to the persistent knowledge graph. 'Buffered' shows how many edges are waiting; 'promotions/hr' shows how fast they're graduating. A growing buffer with no promotions means edges aren't meeting the confidence threshold for persistence.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 8,
        "y": 205
      },
      "targets": [
        {
          "expr": "sum(qortex_buffer_edges)",
          "legendFormat": "buffered"
        },
        {
          "expr": "sum(rate(qortex_edges_promoted_total[1h]))",
          "legendFormat": "promotions/hr"
        }
      ]
    },
    {
      "title": "Total Promoted (lifetime)",
      "description": "Cumulative count of online edges that have been promoted from the buffer into the persistent knowledge graph. This is the system's 'crystallized learning' \u2014 relationships it discovered at runtime and deemed confident enough to keep permanently.",
      "type": "stat",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 16,
        "y": 213
      },
      "targets": [
        {
          "expr": "sum(qortex_edges_promoted_total)",
          "legendFormat": "total promoted"
        }
      ]
    },
    {
      "title": "Search & Retrieval",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 221
      },
      "collapsed": false
    },
    {
      "title": "Query Pipeline",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 222
      },
      "options": {
        "content": "flowchart LR\n    Q(\"Query\") --> E(\"Embed\")\n    E --> V(\"Vec Search\")\n    V --> PPR(\"PPR\\n(graph mode)\")\n    V --> R(\"Results\")\n    PPR --> R\n    style Q fill:#1a1a2e,stroke:#16213e,color:#e94560,stroke-width:2px\n    style E fill:#16213e,stroke:#0f3460,color:#e94560,stroke-width:2px\n    style V fill:#0f3460,stroke:#533483,color:#e94560,stroke-width:2px\n    style PPR fill:#533483,stroke:#e94560,color:#e94560,stroke-width:2px\n    style R fill:#e94560,stroke:#e94560,color:#1a1a2e,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#0f3460\",\"lineColor\":\"#e94560\",\"textColor\":\"#e94560\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 230
      },
      "options": {
        "mode": "markdown",
        "content": "## Retrieval Pipeline\n\nEvery query follows: **embed \u2192 vector search \u2192 (optional) PPR re-rank \u2192 assemble results**.\n`mode=vec` skips PPR entirely. `mode=graph` adds Personalized PageRank for KG-aware re-ranking.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Query Rate** | Queries/sec by mode | Steady throughput, proportional to traffic | Drops = upstream issues or backpressure |\n| **Query Latency** | p50/p95/p99 end-to-end | p50 < 100ms, p99 < 500ms | p99 spikes while p50 flat = subset hitting slow paths |\n| **Vec Search Latency** | Vector-only search time | Sub-millisecond for in-memory | Spikes = index too large or needs rebuild |\n| **Query Errors** | Failures by stage | Zero | Non-zero = queries being dropped |"
      },
      "transparent": true
    },
    {
      "title": "Queries (total & recent)",
      "description": "Retrieval queries by mode (vec = vector-only, graph = GraphRAG with PPR). Shows raw totals (useful at low volume) and per-interval increase. At dev scale, rate/sec is meaningless \u2014 watch the totals climb instead.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 238
      },
      "targets": [
        {
          "expr": "sum by (mode) (qortex_queries_total)",
          "legendFormat": "total ({{mode}})"
        },
        {
          "expr": "sum by (mode) (increase(qortex_queries_total[$__rate_interval]))",
          "legendFormat": "recent ({{mode}})"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "Query Latency (avg / p50 / p95)",
      "description": "End-to-end query latency. Shows all-time average (always visible if any data exists) plus p50/p95 from a 15m window (needs several queries to populate). At dev scale, the avg line is your friend.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 246
      },
      "targets": [
        {
          "expr": "sum(qortex_query_duration_seconds_sum) / sum(qortex_query_duration_seconds_count)",
          "legendFormat": "avg"
        },
        {
          "expr": "histogram_quantile(0.50, sum(increase(qortex_query_duration_seconds_bucket[15m])) by (le))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, sum(increase(qortex_query_duration_seconds_bucket[15m])) by (le))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Vec Search Latency (avg / p50 / p95)",
      "description": "Latency of the vector similarity search step alone. Shows avg (always visible) plus quantiles from a 15m window. At dev scale, watch avg; at prod scale, watch p95 for index degradation.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 254
      },
      "targets": [
        {
          "expr": "sum(qortex_vec_search_duration_seconds_sum) / sum(qortex_vec_search_duration_seconds_count)",
          "legendFormat": "avg"
        },
        {
          "expr": "histogram_quantile(0.50, sum(increase(qortex_vec_search_duration_seconds_bucket[15m])) by (le))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, sum(increase(qortex_vec_search_duration_seconds_bucket[15m])) by (le))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Query Errors (total)",
      "description": "Query failures by pipeline stage. Shows raw totals (useful at dev scale) plus per-interval increase. Non-zero means queries are being dropped \u2014 check the stage label.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 262
      },
      "targets": [
        {
          "expr": "sum by (stage) (qortex_query_errors_total)",
          "legendFormat": "total ({{stage}})"
        },
        {
          "expr": "sum by (stage) (increase(qortex_query_errors_total[$__rate_interval]))",
          "legendFormat": "recent ({{stage}})"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    },
    {
      "title": "PageRank Convergence",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 270
      },
      "collapsed": false
    },
    {
      "title": "PPR Convergence",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 271
      },
      "options": {
        "content": "flowchart BT\n    TV(\"Teleportation\\nVector\") --> PI(\"Power\\nIteration\")\n    PI -->|\"converge?\"| PI\n    PI --> S(\"Score\\nVector\")\n    S --> R(\"Ranked\\nNodes\")\n    style TV fill:#0d1b2a,stroke:#1b263b,color:#e0e1dd,stroke-width:2px\n    style PI fill:#1b263b,stroke:#415a77,color:#e0e1dd,stroke-width:2px\n    style S fill:#415a77,stroke:#778da9,color:#e0e1dd,stroke-width:2px\n    style R fill:#778da9,stroke:#e0e1dd,color:#0d1b2a,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#415a77\",\"lineColor\":\"#778da9\",\"textColor\":\"#e0e1dd\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 279
      },
      "options": {
        "mode": "markdown",
        "content": "## Personalized PageRank\n\nPPR performs **power iteration** over the knowledge graph, biased by teleportation factors, to rank nodes by relevance.\nEach graph-mode query triggers one PPR run. Convergence speed depends on graph structure and factor distribution.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **PPR Executions** | Runs/sec | Tracks graph-mode query rate | Zero while graph queries active = PPR disabled |\n| **Iterations to Converge** | Power iteration steps | Most runs < 20 iterations | Clustering at max (100) = pathological graph |\n| **Active Factors** | Nodes with learned factors | Growing = learning reaches more nodes | Flat = no new feedback reaching new nodes |\n| **Online Edges** | Runtime-discovered relationships | More edges/query = richer associations | 0 edges = co-occurrence detection broken |"
      },
      "transparent": true
    },
    {
      "title": "PPR Executions (total)",
      "description": "Cumulative count of Personalized PageRank computations. Each graph-mode query triggers one PPR run.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 287
      },
      "targets": [
        {
          "expr": "sum(qortex_ppr_started_total)",
          "legendFormat": "PPR runs"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "PPR Iterations to Convergence",
      "description": "Distribution of how many power-iteration steps PPR needs before the score vector stabilizes (within tolerance). Fewer iterations = faster convergence = simpler graph structure. If many runs cluster at the maximum (100), the graph may have pathological structure or the tolerance is too tight.",
      "type": "histogram",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 8,
        "y": 295
      },
      "targets": [
        {
          "expr": "rate(qortex_ppr_iterations_bucket[5m])",
          "legendFormat": "{{le}}"
        }
      ]
    },
    {
      "title": "Active Factors & Node Count",
      "description": "Number of nodes in the knowledge graph that have non-default teleportation factors. These are nodes the system has formed an opinion about based on feedback. Growing = the system is learning about more of the graph. Flat = no new feedback is reaching new nodes.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 16,
        "y": 303
      },
      "targets": [
        {
          "expr": "max(qortex_factors_active)",
          "legendFormat": "active factors"
        }
      ]
    },
    {
      "title": "Online Edge Generation",
      "description": "Online edges generated per query and cumulative generation events. Online edges are runtime-discovered relationships between co-occurring concepts in query results.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 311
      },
      "targets": [
        {
          "expr": "max(qortex_online_edge_count)",
          "legendFormat": "edges / query"
        },
        {
          "expr": "sum(qortex_online_edges_generated_total)",
          "legendFormat": "generation events (total)"
        }
      ]
    },
    {
      "title": "KG Coverage Over Time",
      "description": "Time series of knowledge graph coverage. Shows how the graph's explored territory grows as the system processes queries. Monotonically increasing in a healthy system. Plateaus indicate the system has explored most reachable nodes; jumps indicate new domains or concept batches being ingested.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 319
      },
      "targets": [
        {
          "expr": "max(qortex_kg_coverage)",
          "legendFormat": "coverage"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "min": 0,
          "max": 1,
          "unit": "percentunit"
        }
      }
    },
    {
      "title": "Learning Feedback Loop",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 327
      },
      "collapsed": false
    },
    {
      "title": "Learning Loop",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 328
      },
      "options": {
        "content": "flowchart LR\n    FB(\"Feedback\\naccepted/rejected\") --> TF(\"Teleportation\\nFactors\")\n    TF --> PPR(\"PPR Bias\")\n    PPR --> BQ(\"Better\\nResults\")\n    BQ -.->|\"next cycle\"| FB\n    style FB fill:#3d0066,stroke:#7b2d8e,color:#e0b0ff,stroke-width:2px\n    style TF fill:#7b2d8e,stroke:#9b59b6,color:#e0b0ff,stroke-width:2px\n    style PPR fill:#9b59b6,stroke:#c39bd3,color:#e0b0ff,stroke-width:2px\n    style BQ fill:#c39bd3,stroke:#e0b0ff,color:#3d0066,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#7b2d8e\",\"lineColor\":\"#9b59b6\",\"textColor\":\"#e0b0ff\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 336
      },
      "options": {
        "mode": "markdown",
        "content": "## Learning Dynamics\n\nFeedback drives a **virtuous loop**: accepted results reinforce teleportation factors \u2192 PPR biases toward good nodes \u2192 better results \u2192 more accepts.\nFactor **entropy** measures how much the system has learned. High = uniform (no opinion). Low = concentrated (strong preferences).\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Factor Mean** | Avg teleportation factor | Rising = learning stronger preferences | Falling = conflicting signals |\n| **Factor Entropy** | Distribution spread | Decreasing over time | Flat = no learning happening |\n| **Update Rate** | Factor changes by outcome | Active flow, accepts > rejects over time | Zero = no feedback reaching factors |\n| **Accept/Reject Ratio** | Raw feedback signal | Trending toward more accepts | Sustained high rejection = domain mismatch |"
      },
      "transparent": true
    },
    {
      "title": "Factor Mean Over Time",
      "description": "Average teleportation factor across all nodes in the knowledge graph. Teleportation factors control how strongly PPR biases toward specific nodes during random walks. A rising mean indicates the system is learning stronger preferences from feedback; a falling mean suggests uncertainty or conflicting signals.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 344
      },
      "targets": [
        {
          "expr": "max(qortex_factor_mean) or vector(1)",
          "legendFormat": "mean factor"
        }
      ]
    },
    {
      "title": "Factor Entropy",
      "description": "Shannon entropy of the teleportation factor distribution. High entropy = factors are spread evenly (the system hasn't formed strong opinions yet). Low entropy = factors are concentrated on a few nodes (the system has learned clear preferences). Entropy should decrease over time as the system accumulates feedback.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 8,
        "y": 352
      },
      "targets": [
        {
          "expr": "max(qortex_factor_entropy) or vector(0)",
          "legendFormat": "entropy"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "bits"
        }
      }
    },
    {
      "title": "Factor Updates",
      "description": "How frequently teleportation factors are being updated, by feedback outcome (accepted/rejected/partial). Each update adjusts how PPR weights specific nodes. High update rates indicate active learning; the balance of accepted vs rejected shows whether the system's suggestions are landing.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 16,
        "y": 360
      },
      "targets": [
        {
          "expr": "sum by (outcome) (qortex_factor_updates_total) or vector(0)",
          "legendFormat": "{{outcome}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Feedback (cumulative)",
      "description": "Rate of user/system feedback events classified as accepted vs rejected. This is the raw signal that drives all learning in qortex \u2014 both teleportation factor updates and bandit posterior updates. A healthy system trends toward more accepts over time as learning kicks in. A sustained high rejection rate may indicate poor initial candidates or a domain mismatch.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 368
      },
      "targets": [
        {
          "expr": "sum(qortex_feedback_total{outcome=\"accepted\"}) or vector(0)",
          "legendFormat": "accepted"
        },
        {
          "expr": "sum(qortex_feedback_total{outcome=\"rejected\"}) or vector(0)",
          "legendFormat": "rejected"
        }
      ]
    },
    {
      "title": "Ingestion Pipeline",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 376
      },
      "collapsed": false
    },
    {
      "title": "Ingestion Flow",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 377
      },
      "options": {
        "content": "flowchart LR\n    TXT(\"Raw Text\") --> LLM(\"LLM\\nEnrichment\")\n    LLM --> TR(\"Structured\\nTriples\")\n    TR --> KG(\"KG Insert\")\n    LLM -.->|\"fail\"| FB(\"Fallback\\nExtraction\")\n    FB --> TR\n    style TXT fill:#3c1518,stroke:#69140e,color:#f2f4f3,stroke-width:2px\n    style LLM fill:#69140e,stroke:#a44200,color:#f2f4f3,stroke-width:2px\n    style TR fill:#a44200,stroke:#d58936,color:#f2f4f3,stroke-width:2px\n    style KG fill:#d58936,stroke:#f2f3ae,color:#3c1518,stroke-width:2px\n    style FB fill:#4a4a4a,stroke:#666,color:#f2f4f3,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#a44200\",\"lineColor\":\"#d58936\",\"textColor\":\"#f2f4f3\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 385
      },
      "options": {
        "mode": "markdown",
        "content": "## Enrichment & Ingestion Pipeline\n\nNew concepts flow: **raw text \u2192 LLM enrichment \u2192 structured triples \u2192 KG insertion**. The LLM extracts entity-relationship triples.\nIf the primary LLM fails, a simpler fallback extractor kicks in. Manifests are batches of concepts grouped by domain.\n\n| Signal | What to watch | Healthy | Investigate |\n|--------|--------------|---------|-------------|\n| **Enrichment Rate** | LLM calls/sec by backend | Steady during ingestion | Zero during active ingestion = LLM down |\n| **Enrichment Latency** | LLM response time | p50 < 2s, p95 < 5s | p95 >> p50 = some docs very hard to enrich |\n| **Fallbacks** | Fallback extraction rate | Zero (primary LLM works) | Non-zero = LLM unreliable, consider switching |\n| **Ingestion Rate** | Manifests/sec by domain | Spikes on bulk import, steady otherwise | Zero = no new content entering the system |"
      },
      "transparent": true
    },
    {
      "title": "Ingestion Rate",
      "description": "Rate of manifest ingestion events by domain. A manifest is a batch of concepts being added to the knowledge graph. Each domain (e.g. 'prompts', 'code', 'docs') tracks independently. Spikes indicate bulk imports; steady rates indicate continuous ingestion pipelines.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 393
      },
      "targets": [
        {
          "expr": "sum by (domain) (rate(qortex_manifests_ingested_total[5m]))",
          "legendFormat": "{{domain}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "cps"
        }
      }
    },
    {
      "title": "Ingest Latency",
      "description": "Time taken to ingest a manifest. Shows p50 and p95 quantiles.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 401
      },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_ingest_duration_seconds_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_ingest_duration_seconds_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "s"
        }
      }
    },
    {
      "title": "Credit Propagation",
      "type": "row",
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 409
      },
      "collapsed": false
    },
    {
      "title": "Credit Flow",
      "type": "jdbranham-diagram-panel",
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 410
      },
      "options": {
        "content": "flowchart BT\n    F(\"foundations\\nalpha += 0.202\") -->|0.95| A(\"algebra\\nalpha += 0.425\")\n    A -->|0.85| LA(\"linear-algebra\\nalpha += 1.0\")\n    style LA fill:#2d6a4f,stroke:#40916c,color:#d8f3dc,stroke-width:2px\n    style A fill:#1b4332,stroke:#40916c,color:#b7e4c7,stroke-width:2px\n    style F fill:#081c15,stroke:#2d6a4f,color:#95d5b2,stroke-width:2px",
        "mermaidThemeVariables": "{\"fontSize\":\"14px\",\"primaryColor\":\"#2d6a4f\",\"lineColor\":\"#40916c\",\"textColor\":\"#d8f3dc\"}"
      },
      "transparent": true
    },
    {
      "title": "",
      "type": "text",
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 418
      },
      "options": {
        "mode": "markdown",
        "content": "## Causal Credit Assignment\n\nFeedback (`accepted` / `rejected` / `partial`) propagates **backward** through the causal DAG.\nDirect concepts get full credit. Ancestors get decayed credit: `0.5x` per hop, weighted by edge strength.\nNegative outcomes push `beta` instead of `alpha`.\n\n| Concept | Method | Credit Math | Update |\n|---------|--------|-------------|--------|\n| **linear-algebra** | direct | `1.0` | `alpha += 1.0` |\n| **algebra** | ancestor (1 hop) | `1.0 x 0.5 x 0.85` | `alpha += 0.425` |\n| **foundations** | ancestor (2 hops) | `0.425 x 0.5 x 0.95` | `alpha += 0.202` |\n\n| Signal | Healthy | Investigate |\n|--------|---------|-------------|\n| **Propagation Rate** | Matches feedback rate | Zero while feedback flows = flag off or empty DAG |\n| **Concepts/Propagation** | p50 of 3-5 | p50=1 = no ancestor credit (disconnected DAG) |\n| **Total Propagations** | Monotonically increasing | Stuck at 0 = feature not active |\n| **Alpha vs Beta** | Alpha ahead = net positive signal | Beta dominating = users rejecting results |\n\n`QORTEX_CREDIT_PROPAGATION=on` / Dogfood: `uv run python scripts/demo_credit_propagation_live.py`"
      },
      "transparent": true
    },
    {
      "title": "Credit Propagations",
      "description": "Propagations/sec through the causal DAG, by learner.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 0,
        "y": 426
      },
      "targets": [
        {
          "expr": "sum by (learner) (qortex_credit_propagations_total) or vector(0)",
          "legendFormat": "{{learner}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "ops"
        }
      }
    },
    {
      "title": "Concepts per Propagation",
      "description": "How many concepts receive credit per event. Direct + ancestors. Higher = deeper DAG activation.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 434
      },
      "targets": [
        {
          "expr": "histogram_quantile(0.50, rate(qortex_credit_concepts_per_propagation_bucket[5m]))",
          "legendFormat": "p50"
        },
        {
          "expr": "histogram_quantile(0.95, rate(qortex_credit_concepts_per_propagation_bucket[5m]))",
          "legendFormat": "p95"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short",
          "noValue": "0"
        }
      }
    },
    {
      "title": "Total Credit Propagations",
      "description": "Lifetime propagation count since restart.",
      "type": "stat",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 4,
        "w": 8,
        "x": 0,
        "y": 442
      },
      "targets": [
        {
          "expr": "sum(qortex_credit_propagations_total) or vector(0)",
          "legendFormat": "{{learner}}"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short",
          "noValue": "0"
        }
      }
    },
    {
      "title": "Credit Alpha vs Beta Deltas",
      "description": "Cumulative success (alpha) vs failure (beta) signal from credit propagation.",
      "type": "timeseries",
      "datasource": {
        "type": "prometheus",
        "uid": "${DS_PROMETHEUS}"
      },
      "gridPos": {
        "h": 8,
        "w": 16,
        "x": 8,
        "y": 446
      },
      "targets": [
        {
          "expr": "sum(qortex_credit_alpha_delta_total) or vector(0)",
          "legendFormat": "alpha (success)"
        },
        {
          "expr": "sum(qortex_credit_beta_delta_total) or vector(0)",
          "legendFormat": "beta (failure)"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "short"
        }
      }
    }
  ],
  "schemaVersion": 39,
  "tags": [
    "qortex",
    "observability"
  ],
  "templating": {
    "list": [
      {
        "name": "DS_PROMETHEUS",
        "type": "datasource",
        "query": "prometheus",
        "current": {
          "text": "Prometheus",
          "value": "Prometheus"
        },
        "hide": 2
      }
    ]
  },
  "time": {
    "from": "now-1h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "",
  "title": "qortex Observability",
  "uid": "qortex-main",
  "version": 1
}
